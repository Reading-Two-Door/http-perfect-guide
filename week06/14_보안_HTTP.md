## 공부 내용

- 보다 중요한 트랜잭션을 위해서는, HTTP와 디지털 암호화 기술을 결합해야 한다.
- HTTP의 보안 버전은 효율적이고, 이식성이 좋아야 하고, 관리가 쉬워야 하며, 현실 세계의 변화에 적응력이 좋아야 한다.

- 다음을 제공할 수 있는 HTTP 보안 기술
  - 서버 인증 - 클라이언트는 자신이 위조된 서버가 아닌 진짜와 통신함을 알 수 있어야한다.
  - 클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 통신함을 알 수 있어야한다.
  - 무결성 - 데이터가 위조되는 것으로 부터 안전해야한다.
  - 암호화 - 도청에 대한 걱정이 없어야한다.
  - 효율 - 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야한다.
  - 편재성 - 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
  - 관리상 확장성 - 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
  - 적응성 - 현재 알려진 최선의 보안 방법을 지원해야 한다.
  - 사회적 생존성 - 사회의 문화적, 정치적 요구를 만족시켜야 한다.

### HTTPS

- HTTP를 안전하게 만드는 방식 중 가장 인기 있는 것이다.
- HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화 되며 HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작한다.
- 어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리안에서 일어나기 때문에 웹 클라이언트와 서버가 프로토콜을 변경하는 로직을 크게 변경할 필요가 없다.
- HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것
- 분산된 웹 애플리케이션의 광역 보안 관리에 있어 대단히 중요하다.

### 디지털 암호학

- 암호 - 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- 키 - 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계 - 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계 - 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- 공캐기 암호법 - 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명 - 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서 - 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보
  <br />
  <br />

- 암호법은 메시지 인코딩과 디코딩에 대한 과학이자 기술
- 암호는 단순히 숨기기 위함이 아니라 메시지의 변조를 방지하기 위해 사용할 수 도 있다.
- 디지털 계산의 도래로 인한 발전

  - 속도 및 기능에 대한 기계 장치의 한계에서 벗어남으로써, 복잡한 인코딩과 디코딩 알고리즘이 가능해짐
  - 매우 큰 키를 지원하는 것이 가능해져서, 무작위 추측으로 인한 크래킹이 어려워짐

- 열거 공격 - 무차별로 모든 키를 대입해보는 방법

  - 방지를 위해 키의 길이가 아주 중요하다.

- 대칭키 암호 - 인코딩과 디코딩 시 사용하는 키가 동일하다. 발송자와 수신자가 둘 다 공유키를 가져야 한다.

- 공개키 암호 - 두 개의 비대칭 키를 사용. 하나는 호스트의 메시지를 인코딩하기 위한 것이며 다른 하나는 호스트의 메시지를 디코딩하기 위한 것이다. 인코딩 키는 모두를 위해 공개되어 있지만 호스트 만이 디코딩 키를 알고 있다.

  - 키의 분리는 메시지의 인코딩은 누구나 할 수 있도록 해주는 동시에, 메시지를 디코딩하는 능력은 소유자에게만 부여한다.
  - 공개키 암호화 기술은 보안 프로토콜을 전 세게의 모든 컴퓨터 사용자에게 적용하는 것을 가능하게 했다.
  - 공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있다. 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰인다.

- RSA - 공개키 비대칭 암호는 비밀인 개인 키를 계산할 수 없다는 것을 확신시켜 주는 것이 필요하다. RSA는 공개키, 가로챈 암호문의 일부, 메시지와 그것을 암호화한 암호문을 알더라도 개인 키를 계산할 수 없는 유명한 암호 체계다.

#### 디지털 서명

- 암호 체계는 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명하는 데 이용될 수 있다.
- 디지털 서명은 메시지에 붙어 있는 특별한 암호 체크섬이다.
  - 저자는 극비 개인 키를 갖고 있기 때문에 오직 저자만이 이 체크섬을 계산할 수 있다. 즉, 체크섬은 저자의 개인 서명처럼 동작한다.
  - 메시지 위조를 방지한다. 악의적으로 메시지를 공격했다면 체크섬은 더 이상 메시지와 맞지 않게 된다.
- 디지털 서명은 보통 비대칭 공개키에 의해 생성된다.

#### 디지털 인증서

- 디지털 인증서는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다.
- 공식적으로 '인증 기관'에 의해 디저털 서명된 정보의 집합이 담겨있다.
  - 대상의 이름
  - 유효 기간
  - 인증서 발급자
  - 인증서 발급자의 디지털 서명
- 디지털 인증서는 대상과 사용된 서명 알고리즘에 대한 서술적인 정보뿐 아니라 대상의 공개키도 담고 있다.
- 누구나 디지털 인증서를 만들 수 있지만 인정 받은 서명 권한을 얻을 수 있는 것은 아니다.
- 디지털 인증서에 대한 전 세계적인 단일 표준은 없다. 그러나 대부분 X.509라 불리는 표준화된 서식을 사용한다.

- X.509 - 인증 정보를 파싱 가능한 필드에 넣어 구조화하는 표준화된 방법을 제공한다.

- 사용자가 HTTPS 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다. 만약 서버가 인증서를 갖고 있지 않다면, 보안 커넥션은 실패한다.
- 서버 인증서는 웹사이트의 이름과 호스트명, 웹 사이트의 공개키, 서명 기관의 이름, 서명 기관의 서명을 포함한다.

### HTTPS 세부사항

- HTTP 메시지를 TCP로 보내기 전에 암호화하는 보안 계층으로 보낸다.
- 서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서 핸드셰이크하고 암호화된 HTTP 명령이 뒤를 잇는다.
- SSL 트래픽은 바이너리 프로토콜이기 떄문에, HTTP와는 완전히 다르다.
- TCP 연결이 되고 나면 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화 한다. 핸드셰이크가 완료되면 SSL초기화는 완료되며, 메시지를 보안 계층에 보낼 수 있다.

#### SSL 핸드셰이크

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성

1. 클라이언트가 암호 후보 전달과 함께 인증서 요구
2. 서버는 선택한 암호와 인증서 전송
3. 클라이언트가 비밀정보 전송 후 클라이언트와 서버는 키 생성
4. 클라이언트와 서버는 서로 암호화를 시작한다고 통신

#### 서버 인증서

- SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호 작용을 지원한다.
- 요즘 사용자는 클라이언트 인증서를 가지고 있지 않을 뿐더러 웹 브라우징에서는 자주 쓰이지 않음
- 서버 인증서는 필수로 조직의 이름, 주소, 서버DNS 도메인 이름, 그 외 정보가 있는 X.509에서 파생된 인증서다.

#### 사이트 인증서 검사

- SSL 자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하지 않지만, 최신 웹브라이저들 대부분은 인증서에 대해 간단하게 기본적인 검사를 하고 그 결과를 더 철저한 검사를 할 수 있는 방법과 함께 사용자에게 알려준다.

- 날짜 검사 - 인증서의 유효함을 위해 시작 및 종료일을 검사
- 서명자 신뢰도 검사 - 브라우저가 잘 알려져 있지 않은 인증기관으로부터 서명된 인증서를 받으면 경고를 보여준다.
- 서명 검사 - 서명 기관이 믿을 만하다고 판단하면, 서명기관의 공개키를 서명에 적용하여 체크섬과 비교해봄으로써 인증서의 무결성을 검사한다.
- 사이트 신원 검사 - 트래픽을 가로채는 것을 방지하기 위해 대부분의 브라우저는 인증서의 도메인 이름이 대화 중인 서버의 도메인 이름과 비교하여 맞는지 검사한다.

#### 가상 호스팅과 인증서

- 웹 서버 프로그램은 하나의 인증서만을 지원하기에 가상 호스팅을 하면 인증서의 이름과 맞지 않는 경고가 발생한다.
- 문제를 피하기 위해 보안 트랜잭션을 시작하는 모든 사용자를 리다이렉트한다.

### 진짜 HTTPS 클라이언트

- SSL은 복잡한 바이너리 프로토콜이다. 그래서 프로그래밍을 쉽게 만들어주는 라이브러리가 존재한다. ex) OpenSSL

### 프락시를 통한 보안 트래픽 터널링

- 보안을 위한 프락시는 방화벽 라우터가 HTTP 트래픽의 교환을 허락한 유일한 장치이며, 바이러스 검사나 기타 콘텐츠 제어를 수행할 것이다.
- 하지만 클라이언트가 데이터를 서버의 공개키로 암호화했다면 프락시 서버는 헤더를 읽을 수 없다. 즉, 요청을 어디로 보내야하는지 모른다.
- HTTPS SSL 터널링 프로토콜을 사용해서, 클라이언트는 프락시에게 연결하고자 하는 호스트와 포트를 암호화되기전 평문으로 말해준다. CONNECT 헤더 사용

## 알게된 점

### SSL 커넥션은 어떻게 첫 연결이 후 연결을 유지할 수 있는가? TCP 지속 커넥션이 유지되는 것인가, 첫 연결 시에 공개키를 주고 받기 때문에 키가 있다면 이미 커넥션을 맺었다라고 판단을 하는건가?

- SSL(혹은 현재 더 많이 사용되는 TLS) 커넥션은 일반적으로 TCP 커넥션 위에서 동작하며, 이 커넥션이 유지되는 동안에는 SSL/TLS 세션을 유지할 수 있습니다. SSL/TLS의 핵심 목표 중 하나는 데이터의 기밀성과 무결성을 보장하는 것이며, 이를 위해 공개키와 비공개키를 사용하는 암호화 방식을 활용합니다.

첫 연결 시에 클라이언트와 서버 간에 "핸드셰이크" 과정을 거치게 됩니다. 이 과정에서 클라이언트와 서버 모두 각각의 공개키와 비공개키를 생성하고, 클라이언트가 서버의 공개키를 받아 데이터를 암호화하여 전송합니다. 반대로 서버도 클라이언트의 공개키로 암호화된 데이터를 복호화하기 위해 자신의 비공개 키를 사용합니다.

하지만 이런 통신 방식은 매번 새로운 연결마다 핸드셰이크 과정을 거쳐야 하므로 리소스가 많이 소모됩니다. 그래서 SSL/TLS에서는 세션 재사용(Session Resumption) 개념을 도입하였습니다. 첫 번째 핸드셰이크가 완료되면, 그 결과로 생성된 "세션 ID"나 "세션 티켓" 정보가 양쪽에 저장됩니다. 이 후 같은 클라이언트가 다시 연결 요청할 때, 이미 저장된 세션 정보(ID나 티켓)를 제공함으로써 전체 핸드셰이크 단계 없이 빠르게 안전한 연결 상태로 들어갈 수 있게 됩니다.

따라서 SSL/TLS 커넥션이 지속적으로 유지되는 것은 keep-alive 처럼 TCP 연결 자체가 유지되기 때문인 것도 있고, 성능 최적화 및 리소스 절약 차원에서 도입된 '세션 재사용' 메커니즘 때문인 것도 있습니다.

### 세션 재사용(Session Resumption)

- 세션 ID를 사용하는 방법: 첫 번째 SSL/TLS 핸드셰이크가 완료되면, 클라이언트와 서버 모두 해당 세션에 대한 정보와 함께 고유한 세션 ID를 저장합니다. 클라이언트가 다시 연결 요청을 할 때, 이전에 저장된 세션 ID를 제공합니다. 서버는 이 ID를 확인하고 일치하는 세션 정보가 있다면 그것을 로드하여 바로 암호화된 데이터 교환 단계로 넘어갑니다.

  - 장점: 구현이 비교적 간단하고, 초기 SSL/TLS 버전부터 지원되므로 호환성이 좋습니다.
  - 단점: 서버가 각 세션 ID에 대한 상태를 유지해야 하므로 메모리 사용량이 증가합니다. 이는 대규모 시스템에서는 상당한 부하를 초래할 수 있습니다. 또한, 로드 밸런싱 환경에서는 모든 서버가 동일한 세션 정보를 공유해야 하는 문제도 있습니다.

- 세션 티켓을 사용하는 방법: '세션 티켓'은 Stateless Session Resumption에서 도입된 개념으로, 서버가 클라이언트에게 암호화된 '티켓'을 발급합니다. 이 티켓 안에는 필요한 모든 세션 상태 정보가 포함되어 있습니다. 클라이언트가 다음 번 연결 요청 시 이 티켓을 제공하면, 서버는 해당 티켓의 내용대로 바로 암호화된 데이터 교환 단계로 넘어갈 수 있습니다.

  - 장점: 서버가 세션 상태를 유지할 필요가 없으므로(클라이언트가 티켓을 가지고 있음) 메모리 사용량과 관련된 부담이 적습니다. 이러한 '상태 없음(stateless)' 특성 때문에 로드 밸런싱 환경에서도 문제 없이 작동합니다.
  - 단점: 클라이언트와 서버 사이에 추가적인 암호화된 데이터(세션 티켓)를 교환해야 하므로 약간의 추가 오버헤드가 발생합니다. 또한, TLS 1.2부터 지원되므로 이전 버전의 프로토콜과는 호환성 문제가 있을 수 있습니다.

- 위 두 가지 방식 모두 매번 새롭게 합의해야 하는 비밀키 생성 등의 복잡한 합의 과정 없이도 안전하게 데이터 교환 단계로 넘어갈 수 있도록 해줍니다.

## 궁금한 점

- 368p 그림 14-10 A가 서버?
