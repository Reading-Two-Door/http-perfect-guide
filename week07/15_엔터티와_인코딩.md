## 공부 내용

- HTTP는 잘 라벨링된 엔터티를 사용해 다음을 보장할 수 있다.
  - Contnent-Type과 Content-Language를 이용해 브라우저나 다른 클라이언트는 콘텐츠를 올바르게 처리할 수 있다.
  - 엔터티 검사기와 캐시 만료 제어를 이용해 항상 최신 객체를 유지할 수 있다.
  - Accept 관련 헤더들로 사용자의 요구를 만족할 것이다.
  - 범위 요청, 델타 인코딩, 데이터 압축을 통해 네트워크 사이를 빠르고 효율적으로 이동할 것이다.
  - 전송 인코딩 헤더와 Content-MD5 체크섬을 이용해 조작되지 않고 온전하게 도착할 것이다.

### HTTP 엔터티 헤더 필드

- Content-Type - 엔터티에 의해 전달된 객체의 종류
- Content-Length - 전달되는 메시지의 길이나 크기
- Content-Language - 전달되는 객체와 가장 잘 대응되는 자연어
- Content-Encoding - 객체 데이터에 대해 행해진 변형(압축 등)
- Content-Location - 요청 시점을 기준으로, 객체의 또 다른 위치
- Content-Range - 엔터티가 전체에서 어느 부분에 해당하는지 정의
- Content-MD5 - 엔터티 본문의 콘텐츠에 대한 체크섬
- Last-Modified - 서버에서 이 콘텐츠가 생성 혹은 수정된 날
- Expires - 엔터티 데이터가 신선하지 않은 것으로 간주되기 시작하는 날짜
- Allow - 어떤 요청 메서드가 허용되는지
- ETag - 인스턴스에 대한 고유한 검사기(엄밀하게 따지만 엔터티 헤더가 아님)
- Cache-Control - 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자(엄밀하게 따지만 엔터티 헤더가 아님)

### 엔터티 본문

- 엔터티 본문은 가공되지 않은 데이터만을 담고 있다. 즉, 가공되지 않은 날 데이터에 불과하기 떄문에 엔터티 헤더는 그 데이터의 의미에 대해 설명할 필요가 있다.
- 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다.

### Content-Length

- Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다.
- 어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다.
- 청크 인코딩으로 전송하지 않는 이상 필수적으로 있어야한다. 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요하다.
- 잘린 메시지를 캐시하는 위험을 줄이기 위해, 캐싱 프락시 서버는 Content-Length 헤더가 없는 HTTP 본문은 보통 캐시하지 않는다.
- 잘못된 Content-Length를 가지고 있는 경우도 마찬가지로 큰 피해를 유발할 수 있다. 공식적으로 HTTP1.1 유저 에이전트는 잘못된 길이를 받고 그 사실을 인지했을 때 사용자에게 알려주게 되어 있다.
- 지속 커넥션에서는 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려준다. (청크 제외)
- 본문의 콘텐츠가 인코딩되어 있다면 Content-Length 헤더는 인코딩된 본문의 길이를 바이트 단위로 정의한다.

#### 엔터티 본문 길이 판별을 위한 규칙

1. 본문을 갖는 것이 허용되지 않은 타입의 HTTP 메시지에서는, 본문 계산을 위한 Content-Length 헤더가 무시된다. ex) HEAD
2. 메시지가 Transfer-Encoding 헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 "0 바이트 청크"라 불리는 특별한 패턴으로 끝나야 한다.
3. 1,2 번에 해당 사항이 없다면 Content-Length 값은 본문의 길이를 담게 된다.
4. multipart/byteranges 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의할 것이다. 멀티파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔터티 본문 유형이다.
5. 1,2,3,4의 규칙에 해당되지 않으면 엔터티는 커넥션이 닫힐 때 끝난다. 실질적으로 오직 서버만에 커넥션을 닫을 수 있다.
6. HTTP/1.1에서 요청 본문은 있지만 Content-Length가 없다면 길이를 판별할 수 없는 경우 400 응답을 보내고 유효한 Content-Length 를 요구하고 싶으면 411 응답을 보내길 권장한다.

### 엔터티 요약

- TCP/IP 신뢰할 만한 전송 프로토콜 위에서 구현됨에도 불완전한 트랜스코딩 프락시나 버그 많은 중개자 프락시를 비롯한 여러가지 이유로 메시지의 일부분이 전송 중에 변형되는 일이 일어난다.
- 엔터티 본문에 대한 의도치 않은 변경 감지를 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며, 수신자는 모든 의도하지 않은 변경을 잡기 위해 그 체크섬으로 기본 검사를 할 수 있다.
- MD5로 메시지 무결성 검사에 더해, 문서의 위치를 빠르게 알아내고 콘텐츠 중복 저장을 방지하기 위한 해시 테이블의 키로 이용될 수 있다.
- HTTP의 확장들은 IEFE 초안으로 다른 요약 알고리즘들을 제안했다. 클라이언트가 응답에 대해 기대하는 요약 유형을 정의할 수 있는 새로운 헤더인 Want-Digest를 제안했다.

### 미디어 타입과 Charset

- Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다.
- MIME 타입은 전달되는 데이터 매체의 기저 형식의 표준화된 이름이다.
- Content-Type의 값은 인터넷 할당 번호 관리기관에 등록된 표준화된 MIME 타입이다.
- MIME 타입은 주미디어/부타입 으로 구성된다.
- Content-Type 헤더는 원본 엔터티 본문의 미디어 타입을 명시한다. 즉, 인코딩을 거친 경우에도 인코딩 전의 엔터티 본문 유형을 명시한다.
- Content-Type 헤더는 내용 유형을 자세히 지정하기 위한 선택적인 매개변수도 지원한다.
- charset - 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 매개변수
- multipart는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내진다. 각 구성요소는 자신에 대해 서술하는 헤더를 포함한다. HTTP는 multipart를 지원하지만 일반적으로 폼을 제출하거나 문서의 일부분을 실어 나르는 범위 응답을 할 때에만 사용된다.
- multipart 본문은 여러 다른 종류와 길이의 값으로 채워진 폼을 허용한다.
- boundary는 본문의 서로 다른 부분을 구분하기 위한 구분자로 쓰인다.
- multipart 범위응답의 경우 Content-Type: multipart/byteranges 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 온다.

### 콘텐츠 인코딩

- 서버 전송 시간을 단축하기 위해 압축하거나 암호화하거나 뒤섞어 보내는 경우 발송하는 쪽에서 인코딩을 한다.
- 인코딩 과정
  1. 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다.
  2. 서버가 인코딩된 메시지를 생성한다. 인코딩된 메시지는 Content-Type은 같지만 Content-Length는 다르다. 서버는 Content-Encoding 헤더를 인코딩된 메시지에 추가하여, 수신 측이 디코딩할 수 있도록 한다.
  3. 수신 측은 인코딩된 메시지를 로드해 디코딩하고 원본을 얻는다.
- HTTP는 몇 가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다.
- 인코딩은 각 콘텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화된다.
- gzip, compress, deflate 인코딩은 전송되는 메시지의 크기를 정보 손실 없이 줄이기 위한 무손실 압축 알고리즘이며 gzip은 일반적으로 가장 효율적이고 가장 널리 쓰이는 압축 알고리즘이다.
- 클라이언트는 자신이 지원하는 인코딩의 목록을 Accept-Encoding 요청 헤더를 통해 전달한다. 없는 경우 어떤 인코딩이든 받아들일 수 있는 것으로 간주한다.
- 클라이언트는 각 인코딩에 q값을 매개변수로 더해 선호도를 나타낼수 있다. 1.0은 가장선호 0.0은 가장 선호하지 않음
- identity는 아무런 인코딩도 적용되지 않았음을 의미하는 값, 즉 압축되지 않은 원본을 요청

### 전송 인코딩과 청크 인코딩

- 전송 인코딩 또한 엔터티 본문에 적용되는 가역적 변환이지만, 그들은 구조적인 이유 떄문에 적용되는 것이며 콘텐츠의 포맷과는 독립적이다.
- 전송 인코딩된 메시지는 전체 메시지에 적용되어 메시지 자체의 구조를 바꾼다.
- 전송된 메시지의 본문이 문제를 일으키는 이유
  - 알 수 없는 크기 - 메시지 본문의 크기를 알기 전에 데이터의 전송을 시작하는 경우
  - 보안 - 공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 뒤섞여버리는 방법(SSL로 인해 흔하지 않음)

#### Transfer-Encoding 헤더

- Transfer-Encoding- 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.
- TE - 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용하며 선호하는 인코딩을 q 값을 통해 알릴 수 있다. 그러나 HTTP/1.1 명세는 청크 인코딩에 q 값이 0.0을 갖는 것을 금지한다.

#### 청크 인코딩

- 메시지를 일정 크기의 청크로 쪼갠 후 순차적으로 보낸다.
- 청크 인코딩을 이용하면 메시지를 보내기전에 전체 크기를 알 필요가 없어진다. 본문이 동적으로 생성됨에 따라, 서버는 그중 일부를 버퍼에 담은 뒤 청크를 크기와 함께 보낼 수 있다.
- 청크 인코딩은 전송 인코딩의 한 형태이며 본문이 아닌 메시지의 속성이다.
- 지속 커넥션에서는 반드시 Content-Length 헤더에 본문의 길이를 담아서 보내줘야 한다.
- 서버는 크기가 0인 청크로 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지할 수 있다.
- 클라이언트는 서버가 청크 인코딩을 받아들여줄지 모르기 때문에 411 응답에 대한 대비를 해야한다.

#### 콘텐츠와 전송 인코딩의 조합

- 콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.
- 콘텐츠 인코딩이 먼저 발생하고 전송 인코딩이 발생

#### 전송 인코딩 규칙

- 전송 인코딩 집합은 반드시 chunked를 포함해야한다. 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우 뿐이다.
- 청크 전송 인코딩이 사용되었다면, 마지막 전송 인코딩이 존재해야한다.
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다.
- 서버가 이해할 수 없는 전송 인코딩 메시지를 받았다면 501상태 코드로 응답해야하며, 어떠한 HTTP/1.1 애플리케이션이라도 최소한 청크 인코딩만은 지원해야 한다.

### 시간에 따라 바뀌는 인스턴스

- 웹 객체는 정적이지 않고 같은 URL은 시간에 따라 다른 버전의 객체를 가리킬 수 있다.
- 인스턴스 조작 - HTTP 프로토콜은 어떤 특정한 종류의 요청이나 응답을 다루는 방법들을 정의한다.
  - 범위 요청과 델타 인코딩 - 클라이언트가 자신이 갖고 있는 리소스 사본과 서버가 갖고 있는 것이 같은지 판단하고, 상황에 따라 새 인스턴스를 요청할 수 있는 능력을 가질 것을 요구

### 검사기와 신선도

- 조건부 요청은 클라이언트가 서버에게 자신이 갖고 있는 버전을 말해주고 검사기를 사용해 사본이 더 이상 유효하지 않을 때만 사본을 보내달라고 요청하는 것이다.
- 캐시의 신선도는 Expires나 Cache-Control 헤더를 통해 정보 제공 가능
- 서버의 문서가 캐시가 가진 사본과 같음에도 항상 그 문서를 가져온다면 네트워크 대역폭을 낭비하고, 캐시와 서버에 불필요한 부하를 주고, 모든 것을 느려지게 만들게 된다. 이를 개선하기 위해 리소스가 변경된 경우에만 사본을 요청하는 조건부 요청을 제공한다.
- 조건부 요청은 'If-'로 시작하는 조건부 헤더에 의해 구현되며 조건이 참일 떄만 수행된다. 참이 아니면 에러 코드를 돌려보낸다.
- 검사기는 문서의 테스트된 특정 속성이다. ex) 일련번호, 버전 번호, 문서의 최종 변경일 등

#### 검사기 유형

| 요청 유형           | 검사기        | 설명                                                                                                                                                                                                                                            |
| ------------------- | ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| If-Modified-Since   | Last-Modified | 지난번 Last-Modified 응답 헤더에 들어있던 날짜 이후에 지정된 자원이 변경되었을 때만 자원을 반환하도록 서버에 요청                                                                                                                               |
| If-Unmodified-Since | Last-Modified | 지난번 Last-Modified 웅답 헤더에 들어있던 날짜 이후에 지정된 자원이 변경되지 않았을 때만 자원을 반환하도록 서버에 요청 <br/> 지정된 시간 이후로 리소스가 수정되었다면, 서버는 412 (Precondition Failed) 상태 코드를 응답                        |
| If-Match            | ETag          | 클라이언트가 지정한 ETag 값과 서버의 현재 자원의 ETag 값이 일치할 때만 요청을 수행하도록 서버에 지시 <br /> 두 값이 일치하지 않으면, 즉 클라이언트가 가진 자원의 버전과 서버의 자원 버전이 다르면, 서버는 412 Precondition Failed 응답을 반환   |
| If-None-Match       | ETag          | ETag 값들 중 어느 것도 현재 서버의 자원 ETag와 일치하지 않을 경우에만 요청을 수행하도록 서버에 지시<br /> 만약 클라이언트가 제공한 ETag와 일치하는 리소스가 있다면, 304 Not Modified 상태 코드를 반환하고 새로운 본문 데이터를 전송하지 않는다. |

- HTTP는 검사기를 약한 검사기와 강한 검사기 두 가지로 분류한다.
- 약한 검사기는 리소스의 인스턴스를 고유하게 식별하지 못하는 경우도 있다. 강한 검사기는 언제나 고유하게 식별한다. 약한 검사기는 객체의 바이트 단위 크기가 있고 강한 검사기는 암호 체크섬(MD5)이 있다.
- Last-Modified는 약한 검사기로 간주된다. 정확도가 최대 1초에 불과하기 때문이다. 1초에 리소스가 여러번 변경될 수 있고 최종 변경 시각은 변경이 발생했음을 항상 반영해주지는 못한다.
- ETag는 강한 검사기로 간주된다. 매 변경마다 구분되는 값을 넣어두기 때문이다. ETag는 어떤 텍스트 값도 가질 수 있기에 유연하다. 태그앞에 w/를 붙여 약한 엔터티 대그임을 알릴 수 있다.

### 범위 요청

- HTTP는 문서의 일부분이나 특정 범위만 요청할 수 있도록 할 수 있다.
- 범위 요청을 이용하면, HTTP는 받다가 실패한 엔터티를 일부 혹은 범위로 요청함으로써 다운로드를 중단된 시점에서 재개할 수 있다.
- Range 헤더로 몇 바이트 이후의 부분을 요청할 수 있다.

### 델타 인코딩

- 델타 인코딩은 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화하는, HTTP 프로토콜의 확장이다.
- 델타 인코딩은 어떤 객체의 특정 인스턴스들에 대한 클라이언트와 서버 사이의 정보 교환에 의존하기 때문에 일종의 인스턴스 조작이다.
- 클라이언트는 서버에게 A-IM을 헤더를 보내 자신이 델타를 받아들일 수 있음을 알려줄 수 있다. A-IM 헤더에는 최신 버전의 문서를 생성하는 방법에 대해 자신이 알고 있는 알고리즘을 명시한다.
- 서버는 226 응답 코드와 IM헤더, 새 ETag 헤더, 이전 ETag 담은 Delta-Base헤더를 되돌려준다.
- 델타 인코딩은 전송 시간을 줄일 수 있지만 구현하기가 까다롭다.

## 알게된 점

### If-Modified-Since

- 목적: 이 헤더는 클라이언트가 가지고 있는 리소스의 사본이 최신인지 확인하려고 할 때 사용됩니다. 클라이언트는 자신이 가진 리소스의 마지막 수정 시간을 If-Modified-Since 값으로 설정하여 요청을 보냅니다.
- 결과: 만약 서버에서 관리하는 리소스가 이 시간 이후로 변경되었다면, 서버는 새로운 버전의 리소스와 함께 200 OK 상태 코드를 반환합니다. 그러나 리소스가 해당 시간 이후로 변경되지 않았다면, 서버는 304 Not Modified 상태 코드를 반환하며 본문은 비워둡니다. 이 응답은 클라이언트에게 "너가 가진 사본은 여전히 최신인 것"을 알려주므로, 네트워크 대역폭을 절약할 수 있습니다.

### If-Unmodified-Since

- 목적: 반대로, If-Unmodified-Since 헤더는 클라이언트가 작업하기 전에 해당 리소스가 변경되지 않았음을 보장하려고 할 때 사용됩니다. 예를 들어 어떠한 파일 업데이트 작업 등에서 중요한 경우입니다.
- 결과: 만약 해당 날짜 이후로 리소스가 수정되었다면, 서버는 412 Precondition Failed 상태 코드를 반환합니다. 이 응답은 "작업하기 원하는 데이터가 이미 다른 곳에서 변경되어 충돌 가능성이 있다"는 것을 알려줍니다.

### 청크 메세지의 트레일러

HTTP 청크 전송 인코딩에서 트레일러는 메시지 본문의 끝을 표시하는 역할을 합니다.

청크 전송 인코딩은 웹 서버가 동적으로 생성되는 콘텐츠를 클라이언트에게 보낼 때 유용하게 사용됩니다. 이런 경우, 콘텐츠의 최종 크기를 미리 알 수 없으므로, 서버는 데이터를 여러 '청크'로 나누어 전송합니다. 각 청크는 그 크기와 함께 보내집니다.

트레일러는 마지막 청크가 전송된 후에 옵션으로 보낼 수 있는 HTTP 헤더들입니다. 이것은 마지막 청크인 0 크기의 청크와 함께 보내집니다.

그러나 모든 HTTP 클라이언트나 서버가 트레일러를 지원하지 않으므로, 중요한 정보를 트레일러에 포함하는 것은 권장되지 않습니다.

HTTP/1.1 스펙에 따르면, 메시지 본문이 chunked 전송 인코딩을 사용하여 전송되었다면, 해당 메시지의 Trailer 헤더 필드에 나열된 (만약 있을 경우) 각 헤더 필드는 선택적인 trailer 섹션에서 수신될 수 있습니다.

## 궁금한 점
