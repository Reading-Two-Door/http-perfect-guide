## 공부 내용

- 서버가 통신하는 대상을 식별하는 데 사용하는 기술
- HTTP는 익명으로 사용하며 상태가 없다. 하지만 현대의 웹사이트는 개인화된 서비스를 제공하고 싶어 한다.
  - 개별 인사 - 사용자 맞춤 환영 인사
  - 사용자 맞춤 추천 - 구매 예상 물품 추천
  - 정보 저장 - 주소, 카드번호
  - 세션 추적 - 장바구니 (HTTP 트랜잭션은 상태가 없기 때문에 식별할 방법이 필요하다.)

### 세션 식별 방법

#### HTTP 헤더

- From - 사용자 이메일 주소
- User-Agnet - 사용자 브라우저
- Referer - 사용자가 현재 링크를 타고 온 근원 페이지

#### 클라이언트 IP 주소

- 초기에는 사용자 식별을 IP로 사용하려 했다.
- IP 식별 약점
  - 사용자가 아닌 컴퓨터를 가리키기 때문에 여라 사용자가 같은 컴퓨터를 사용하면 식별할 수 없다.
  - ISP(인터넷 서비스 제공자)는 유저 접속 시 동적으로 IP를 부여한다.
  - NAT(Network Address Transition) 방화벽을 사용하면 실제 IP를 숨기고 방화벽 IP주소로 변환한다.
  - 프락시 서버를 사용하면 프락시 서버 IP를 전달한다. clinet-ip나 X-Forwarded-For HTTP 같은 확장 헤더를 추가해 해결가능하지만 모든 프락시가 이렇게 동작하진 않는다.

#### 사용자 로그인

- IP주소를 사용하는 수동적인 방식보다 웹 서버는 사용자 이름과 비밀번호 인증할 것을 요구해서 명시적으로 식별 요청을 할 수 있다.
- WWW-Authenticate와 Authorization 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.
- 한 번만 로그인하면 브라우저는 요청마다 식별정보 토큰을 Authorization 헤더에 담아 서버로 전송해, 세션이 진행되는 내내 식별을 유지한다.

#### 뚱뚱한 URL

- 사용자의 상태 정보를 포함하고 있는 URL
- 사이트 첫 방문시 유일한 ID가 생성되고, 서버가 인식할 수 있는 방식으로 URL에 추가되며, 서버는 클라이언트를 뚱뚱한 URL로 리다이렉트 시킨다.
- 단점
  - 못생긴 URL 유저에게 혼란을 준다.
  - 주소를 누군가에게 공유 시 개인 정보를 본의 아니게 공유하게 된다.
  - 캐시 사용 불가
  - 서버 부하 가중
  - 이탈 시 진행상황이 초기화 된다.

#### 쿠키

- 쿠키는 사용자를 식별하고 세션을 유지하는 방식 중 현재까지 널리 사용하는 방식
- 쿠키는 캐시와 충돌할 수 있어서, 대부분의 캐시나 브라우저는 쿠키에 있는 내용을 캐싱하지 않는다.
- 쿠키의 타입

  - 파기되는 시점에 따라 결정되며 Expires나 Max-Age 파라미터가 없으면 세션 쿠키다.
  - 세션 쿠키 - 임시 쿠키로 브라우저 종료 시 삭제된다.
  - 지속 쿠키 - 사이트에 대한 설정 정보나 로그인 유지 시 주로 사용

- Set-Cookie 같은 HTTP 응답헤더에 기술되어 사용자에게 전달된다.
- 쿠키의 기본 발상은 브라우저가 서버 관련 정보를 저장하고 사용자가 서버에 접근할 때 마다 그 정보를 함께 전송하는 것이다.
- 브라우저는 쿠키 정보를 저장할 책임이 있는데 이를 클라이언트 측 상태(HTTP 상태 관리 체계)라고 한다.
- 브라우저는 각기 다른 방식으로 쿠키를 저장한다.
- 브라우저는 수백 수천 개의 쿠키를 가지고 있을 수 있지만 일반적으로 2~3개의 쿠키만 보낸다.
  - 쿠키를 모든 전달 시 성능이 크게 저하됨
  - 서버에 특화된 이름/값 쌍을 포함하기에 대부분 사이트에서 인식하지 않는 무의미한 값이다.
  - 개인정보 문제
- 쿠키를 생성할 때 Set-Cookie 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 쿠키를 읽을 수 있는지 제어할 수 있다.
- Path 속성을 활용해 특정 path에만 쿠키를 보낼 수 있다.

- 쿠키 ver0과 ver1 모두 HTTP/1.1 명세로 기술되어 있지는 않다.
- version0
  - 넷스케이프가 정의
  - Set-Cookie 응답 헤더와 Cookie 요청 헤더와 쿠키를 조작하는데 필요한 필드를 정의
  - 이름=값, Expires, Domain, Path, Secure
- version1

  - Set-Cookie2와 Cookie2 헤더를 소개하며 Version0과도 호환된다.
  - version0 표준보다 복잡하며 모든 브라우저나 서버가 완전히 지원하지는 않는다. (그 당시 기준)
  - comment, discard, max-age, port이 추가
  - Cookie2 헤더는 각기 다른 쿠키 버전을 지원하는 클라이언트와 서버 간에 호환성을 협상하는 용도로 사용

- 쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다.
- 쿠키가 다른 사용자에게 할당되거나 개인정보다 노출되는 상황이 발생할 수 있다.
- 캐시를 다루는 원칙

  - 캐시되지 말아야할 문서가 있다면 표시하라
  - Set-Cookie 헤더를 캐시 하는 것에 유의하라
    - 같은 Set-Cookie 헤더를 여러 사용자에게 보내게 되면, 사용자 추적에 실패한다.
    - 어떤 캐시는 응답 저장 전 Set-Cookie헤더를 제거하기에 문제가 발생할 수 있다.
  - Cookie헤더를 가지고 있는 요청을 주의하라
    - Cookie헤더가 함께 오면 결과 콘텐츠가 개인정보를 담고 있을 수도 있다는 힌트
    - 캐시 이미지에 파기 시간이 0인 Cookie 헤더를 설정해 매번 재검사하도록 강제하는 것이 좋다.

- 쿠키를 비활성화 시킬 수 있고, 로그 분석 같은 다른 방법으로 대체하는 것이 가능하므로, 그 자체가 보안상으로 위험한 것은 아니다.
- 쿠키는 제공되는 개인정보를 누가 받는지 명확히 알고 사이트의 개인정보 정책에만 유의한다면 세션 조작이나 트랜잭션 상의 편리함이 더 크다.

## 알게된 점

### 최신 브라우저 기준으로 아직 쿠키 version1의 기능을 완전히 지원하지 않는가?

쿠키의 버전은 크게 Version 0 (Netscape Spec)과 Version 1 (RFC 2109), 그리고 현재 가장 널리 사용되는 Version 2 (RFC 6265)가 있습니다.

Version 1은 상대적으로 오래된 버전으로서 현재 대부분의 최신 브라우저에서도 지원됩니다. 하지만 이 버전은 보안상의 문제와 호환성 문제로 인해 실제로는 많이 사용되지 않습니다.

Version 2 (RFC 6265)가 가장 최신 버전이며, 이 버전은 보안과 호환성을 향상시킨 새로운 규격을 제공합니다. 따라서 대부분의 최신 웹 브라우저는 이 RFC 6265 규격에 따른 쿠키를 완벽하게 지원하고 있습니다.

따라서 일반적으로 모든 최신 브라우저들은 쿠키 Version1의 기능을 완벽하게 지원하지만, 실제 개발 환경에서는 Version2(RFC6265)를 주로 사용하는 것이 일반적입니다.

### RFC 2965의 확장 쿠키와 쿠키 version2에 차이점

- Cookie Processing Rules: RFC 6265에서는 쿠키 처리 규칙을 간소화하고 명확하게 하였습니다. 이로 인해 브라우저 간의 일관성과 예측 가능성을 향상시킬 수 있었습니다.
- Cookie Attributes: RFC 2965에서는 "Comment", "CommentURL", "Discard", "Port" 등의 쿠키 속성들이 도입되었으나, 이들은 실제로 잘 사용되지 않았습니다. 따라서 RFC 6265에서는 이러한 속성들을 제거하였습니다.
- Compatibility: RFC 6265는 실제 웹 브라우저가 쿠키를 어떻게 처리하는지에 대한 관찰 결과를 바탕으로 작성되었습니다. 따라서 이 규격은 실제 웹 환경과 더욱 호환됩니다.
- Security Enhancements: 보안 강화도 중요한 차이점 중 하나입니다. 예를 들어, SameSite 속성은 크로스 사이트 요청 공격(Cross-Site Request Forgery, CSRF)을 방지하는 데 도움을 줍니다.

따라서 주요 차이점은 처리 규칙의 간소화와 명확화, 사용되지 않는 속성의 제거, 호환성 향상, 그리고 보안 강화 등으로 요약할 수 있습니다.

## 궁금한 점
