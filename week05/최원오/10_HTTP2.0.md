## 공부 내용

- HTTP/1.1 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되었다. 그러다 보니 요청 하나를 보내고 그에 대해 응답 하나만을 받는 HTTP의 메시지 교환 방식은 단순함 면에서는 좋았지만 심각한 회전 지연을 있다.
- SPDY 프로토콜은 헤더를 압축하여 대역폭을 절약했고, 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄이는 것이 가능했으며, 서버가 능동적으로 리소스를 푸시하는 기능도 있다.
- SPDY 프로토콜을 기반으로 HTTP/2.0 프로토콜 초안을 만들었다.
- 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있으므로, 여러 개의 요청과 응답을 동시에 처리하는 것 역시 가능하다.
- 서버 푸시 - 클라이언트에게 필요하다고 생각하는 리소스라면 요청을 명시적으로 받지 않더라고 능동적으로 보내줄 수 있다.
- 기존 애플리케이션과 호환성을 최대한 유지하기 위해, HTTP/2.0은 요청과 응답 메시지의 의미를 HTTP/1.1과 같도록 유지하고 있다.

### HTTP/1.1과의 차이점

#### 프레임

- HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송된다.
- 8바이트 크기의 헤더로 시작하며, 최대 16383바이트 크기의 페이로드가 온다.
- HTTP/2.0은 총 10가지 프레임을 정의하고 있으며, 페이로드 형식이나 내용은 종류에 따라 다르다.

- 프레임 필드
  - R - 예약된 2비트 필드로 값의 의미가 정의되어 있지 않으며, 반드시 0이어야 한다.
  - 길이 - 페이로드의 길이를 나타내는 14비트 무부호 정수
  - 종류 - 프레임의 종류
  - 플래그 - 8비트 플래그. 플래그 값의 의미는 프레임의 종류에 따라 다르다.
  - R - 예약된 1비트 필드
  - 스트림 식별자 - 31비트 스트림 식별자. 0은 커넥션 전체와 연관된 프레임 임을 의미

#### 스트림과 멀티플렉싱

- 스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스다.
- 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진다. 클라이언트는 새 스트림을 만들어 그를 통해 HTTP 요청을 보낸다. 요청을 받은 서버는 그 요청과 같은 스트림으로 응답을 보낸다. 이후 스트림이 닫히게 된다.
- 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다.
- 스트림은 우선 순위를 가질 수 있다. 의무사항은 아님
- 스트림이 클라이언트에 의해 초기화 된 경우 식별자는 홀수, 서버라면 짝수 (서버 푸시?)
- 새로 만들어지는 스트림 식별자는 이전에 만들어졌거나 예약된 스트림들의 식별자보다 커야 한다.
- 규칙을 어기는 식별자를 받았다면 PROTOCOL_ERROR 커넥션 에러로 응답해야 한다.
- 서버와 클라이언트는 일방적으로 스트림을 생성하기 때문에 TCP 패킷을 주고 받는라 시간 낭비를 하지 않아도 된다.
- 흐름 제어를 통해, 스트림들이 서로 간섭해서 망가지는 것을 막아준다.

#### 헤더 압축

- 웹페이지 하나를 보기 위해 많은 요청을 보내기 때문에, 헤더의 크기가 회전 지연과 대역폭 양쪽 모두에 영향을 끼치게되면서 헤더의 압축이 필요해짐
- HPACK명세에 정의된 헤더 압축 방법으로 압축된 뒤 헤더 블록 조각들로 쪼개져서 전송된다. 이후 받는 쪽에서 조각들을 이은 뒤 압축을 풀어 원래 헤더 집합으로 복원한다.
- HPACK은 헤더 압축 및 해제 시 압축 콘텍스트를 사용한다.

#### 서버 푸시

- HTTP/2.0은 하나의 요청에 대해 여러 응답이 가능하다. 즉, 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용하다.
- PUSH_PROMISE 프레임을 보내어 미리 알려줘야하며 클라이언트가 프레임을 받게 되면 예약 상태가 된다.
- 클라이언트는 RST_STREAM을 보내어 거부할 수 있으며 스트림은 닫히게 된다.

### 알려진 보안 이슈

#### 중개자 캡슐화 공격

- HTTP/2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩한다. 이는 HTTP/2.0이 헤더 필드로 어떤 문자열이든 사용할 수 있게 해준다. 이는 정상적인 2.0요청이나 응답이 불법적이거나 위조된 1.1 메시지로 번역되는 것을 유발할 수 있다.?

#### 커넥션 유지로 인한 개인정보 유출

## 알게된 점

### TCP 커넥션 초기화

1. TCP 커넥션 설정: 클라이언트는 서버에 대한 TCP 커넥션을 설정하기 위해 SYN 패킷을 보냅니다. 서버는 SYN-ACK 패킷으로 응답하고, 마지막으로 클라이언트가 ACK 패킷을 보내어 커넥션을 설정합니다. 이를 "TCP 3-way handshake"라고 부릅니다.
2. TLS 핸드셰이크 (필요한 경우): HTTP/2.0은 기본적으로 암호화된 연결(즉, HTTPS)을 사용합니다. 따라서 일반적으로 TLS(Transport Layer Security) 핸드셰이크가 수행됩니다. 이 과정에서 클라이언트와 서버는 양방향 암호화 통신을 수립하기 위한 키를 교환합니다.
3. HTTP/2 설정: TCP 및 TLS 핸드셰이크 후에 HTTP/2 프로토콜의 초기화 단계가 진행됩니다.
   클라이언트 프리패스(Preface): HTTP/2 연결의 시작은 클라이언트 프리패스로 시작되며, 이것은 특정 바이너리 시퀀스입니다("PRI \* HTTP/2.0\r\n\r\nSM\r\n\r\n"). 이 시퀀스를 보내는 것은 클라이언트가 HTTP/2를 사용할 준비가 되었음을 서버에 알리는 것입니다.
   세팅 프레임 전송: 그 다음, 클아인트와 서버 모두 SETTINGS 프레임을 주고 받습니다. SETTINGS 프레임은 연결에 대한 구성값들(예: 동시에 열 수 있는 스트림의 최대 개수 등) 을 교환하는 데 사용됩니다.
4. 스트림 생성 및 데이터 교환: 모든 초기화 절차가 완료되면, 실제 요청과 응답 데이터를 교환하기 위해 스트림(Streams) 생성과 관리 작업들이 진행됩니다.

### HTTP/1.0이나 HTTP/1.1에는 프레임의 개념이 존재하지 않는가?

HTTP/1.0 및 HTTP/1.1에서는 "프레임"이라는 개념이 존재하지 않습니다. 이들 프로토콜에서는 요청과 응답이 각각 독립적인 트랜잭션으로 처리되며, 각 트랜잭션은 개별적인 TCP 커넥션을 사용하거나, 지속적인 커넥션을 사용하는 경우에도 순차적으로(즉, 하나의 요청-응답 페어가 완료된 후에 다음 요청-응답 페어가 시작됨) 처리됩니다.

반면에 HTTP/2 및 그 이후의 버전에서는 "프레임"이라는 개념이 도입되었습니다. HTTP/2 프로토콜은 단일 TCP 커넥션 위에서 여러개의 스트림을 동시에 다룰 수 있게 해주며, 각 스트림은 여러개의 메시지로 나뉘고, 그 메시지들은 다시 여러개의 프레임으로 나뉩니다.

각 프레임은 고유한 타입을 가지며 (예: HEADERS, DATA, SETTINGS 등), 그 타입에 따라 서버와 클라이언트 사이에서 교환되는 정보를 나타냅니다. 이런 방식으로 HTTP/2는 단일 연결 위에서 복수의 독립적인 스트림을 동시에 처리할 수 있게 되어 성능과 효율성을 크게 개선하였습니다.

### WINDOW_UPDATE 프레임

- 스트림 레벨에서의 흐름 제어: WINDOW_UPDATE 프레임이 스트림 식별자와 함께 전송되면, 그 스트림에 대한 윈도우 크기를 조정합니다. 이것은 해당 스트림에만 영향을 미칩니다.
- 연결 레벨에서의 흐름 제어: WINDOW_UPDATE 프레임이 스트림 식별자 없이 (즉, 스트림 0으로) 전송되면, 전체 연결에 대한 윈도우 크기를 조정합니다. 이것은 모든 스트림에 영향을 미칩니다.
  윈도우 크기는 수신 측이 송신 측으로부터 받아들일 수 있는 데이터의 양을 결정합니다. 초기 윈도우 크기는 설정된 값으로 시작하며, 그 후 WINDOW_UPDATE 프레임을 통해 동적으로 조정될 수 있습니다.

수신 측이 데이터를 성공적으로 처리하고 추가 데이터를 받아들일 준비가 되었다면, 그것은 WINDOW_UPDATE 프레임을 보내서 송신 측에게 알리게 됩니다.
따라서, WINDOW_UPDATE 프레임은 HTTP/2에서 중요한 역할을 하며, 네트워크 리소스의 효율적인 사용과 공정한 리소스 분배를 가능하게 합니다.

### HPACK과 압축 컨텍스트

1. 정적 및 동적 테이블: HPACK에는 정적 및 동적 두 가지 종류의 테이블이 있습니다. 정적 테이블에는 공통으로 사용되는 HTTP 헤더 필드가 사전 정의되어 있습니다. 동적 테이블은 클라이언트와 서버 간의 연결 중에 업데이트되며, 최근에 사용된 HTTP 헤더 필드를 저장합니다.
2. 인코딩과 디코딩: 클라이언트와 서버 모두 HPACK 인코딩과 디코딩을 수행할 수 있습니다. 이를 통해 원래의 HTTP 메시지를 압축하여 전송하고, 받은 쪽에서는 그것을 다시 원래대로 복원할 수 있습니다.
   "압축 컨텍스트"란 클라이언트와 서버 각각에서 유지하는 상태 정보입니다. 이것은 동적 테이블의 현재 상태를 포함하며, 연결 생명주기 동안 지속됩니다.

클라이언트와 서버 각각의 압축 컨텍스트는 연결 설정 시점에 비어 있는 상태로 시작하며, 그 후 메시지 교환 과정에서 업데이트됩니다.

HTTP/2 메시지가 전송될 때마다, 해당 메시지의 HTTP 헤더 필드들은 HPACK 인코딩 방식으로 압축되고, 이 때 압축 컨텍스트가 참조 및 업데이트됩니다.

받는 쪽에서는 받은 메시지를 처리할 때마다 자신의 압축 컨텍스트를 참조하여 HPACK 디코딩을 수행하고, 필요한 경우 자신의 압축 컨텍스트를 업데이트합니다.

HPACK과 함께 작동하는 이러한 "압축 컨텍스트" 메커니즘 덕분에 HTTP/2는 HTTP 헤더의 효율적인 압축과 전송을 가능하게 합니다.

## 궁금한 점

- 293p HTTP/2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩한다. 이는 HTTP/2.0이 헤더 필드로 어떤 문자열이든 사용할 수 있게 해준다. 이는 정상적인 2.0요청이나 응답이 불법적이거나 위조된 1.1 메시지로 번역되는 것을 유발할 수 있다.?
