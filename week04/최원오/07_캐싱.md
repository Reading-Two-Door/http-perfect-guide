## 공부 내용

- 캐시를 이용하면, 첫 번째 서버 응답은 캐시에 보관된다. 이후 캐시된 사본이 요청에 대한 응답으로 사용된다.
- 캐시에 요청이 도착했을 때, 그에 대응하는 사본이 있다면 cache hit 아니면 cache miss

### 재검사 (Revalidation)

- 캐시는 반드시 사본이 최신인지 확인해야한다. 그러나 네트워크 대역폭이 부족하기 때문에, 대부분의 캐시는 충분히 오래된 경우에만 재검사를 한다.
- 재검사 요청으로 컨텐츠가 유효하다면 304 응답을 보내고 클라이언트에 제공한다.

### If-Modified-Since 헤더

- 캐시된 객체를 재확인하기 위한 가장 많이 쓰이는 도구
- cache hit 시(서버 콘텐츠가 변경되지 않은 경우) => 304 Not Modified 응답
- cache miss => 컨텐츠 전체와 함께 200 응답
- 서버 객체 삭제 => 404 응답과 함께 캐시 사본 삭제

### 적중률

- 캐시가 요청을 처리하는 비율(cache hit 비율)
- 40%면 웹 캐시로 괜찮은 편
- 얼마나 웹 트랜잭션을 외부로 내보내지 않았는지 알 수 있다.

### 바이트 적중률

- 문서 크기가 다 다르기 때문에 적중률 보다 바이트 적중률 측정값을 선호하는 경우도 있다.
- 캐시를 통해 제공된 모든 바이트의 비율
- 트래픽이 절감된 정도를 포착할 수 있다.

### 적중과 부적중 구별

- 둘 다 200 응답을 주기 때문에 Date헤더를 사용하거나 Age 헤더를 사용하여 캐시를 사용했는지 확인가능하다.

### 캐시 토폴로지

- 개인 전용 캐시
  - 웹 브라우저는 개인 전용 캐시를 내장하고 있다.
  - 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용
- 공용 프락시 캐시
  - 자주 찾는 객체를 모든 요청에 대해 공유된 사본을 제공하기에 네트워크 트래픽을 줄인다.

### 프락시 캐시 계층

- 작은 캐시에서 부적중 시 상위 캐시로 캐시 계층을 따라 간다.

### 캐시망

- 캐시망의 프락시 캐시는 복잡한 방법?으로 대화하여 어떤 부모 캐시와 대화할 것인지, 아니면 요청이캐시를 우회해서 원 서버로 가도록 할 것인지에 대해 동적으로 결정을 한다.
- 선택적인 피어링을 지원하는 캐시를 형제 캐시라고 하는데 HTTP는 형제 캐시를 지원하지 않기 때문에, ICP나 HTCP 같은 프로토콜을 이용해 HTTP를 확장했다.

### 캐시 처리 단계

1. 요청 받기
2. 파싱
3. 검색
   - URL을 알아내고 로컬 사본이 있는지 검사
   - 캐시된 객체는 서버 응답 본문과 원 서버 응답 헤더를 포함하고 있다.
4. 신선도 검사
5. 응답 생성
   - 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성
   - Cache-Control, Age, Expires 헤더 등 캐시 신선도 정보를 삽입
6. 전송
7. 로깅
   - 로그 파일과 캐시 사용에 대한 통계를 유지
   - 스쿼드 로그 포맷, 넷스케이프 확장 공용 로그 포맷을 가장 많이 씀

### Cache-Control 캐시 제어

- no-store - 캐시가 응답의 사본을 만드는 것을 금지한다.
- no-cahce - 서버와의 재검사를 필수적으로 하고 사본을 제공한다.
- must-revalidate - stale한 사본은 서버의 재검사를 반드시 하고 제공한다.
- max-stale - 설정 시간만큼 신선하지 않은 문서도 제공
- min-fresh - 설정 시간만큼 신선한 문서만 가능하게 하여 엄격하게 만듬
- only-if-cached - 클라이언트는 캐시에 들어있는 사본만 원함

### 휴리스틱

- max-age나 expires 헤더 중 어느 것도 포함하지 않고 있다면 경험적인 방법으로 기간을 계산한다.
- LM 인자 알고리즘?
- 마지막으로 변경된 것이 아주 오래전이면 안정적인 문서로 간주하고 캐시에 보관

### 캐시

- 문서가 캐시에 도착했을 때의 나이 + 사본이 캐시에 머무른 시간

## 알게된 점

### 대역폭(bandwidth)

대역폭(Bandwidth)은 네트워크에서 전송되는 데이터의 양을 나타내는 매우 중요한 개념입니다. 대역폭은 일반적으로 초당 비트(bps 또는 b/s) 단위로 측정되며, 네트워크 연결의 데이터 전송 속도를 나타냅니다.

네트워크 요청 시 대역폭은 해당 요청이 처리될 수 있는 데이터 양에 영향을 미칩니다. 대역폭이 높을수록 네트워크는 더 많은 데이터를 동시에 처리할 수 있으며, 전송 속도가 빨라집니다. 따라서 대역폭이 클수록 네트워크 성능이 우수하다고 할 수 있습니다.

### 캐시 토폴로지

캐시 토폴로지에서 "토폴로지"는 네트워크 구성 요소들 간의 연결 및 배치 방식을 나타냅니다. 즉, 토폴로지는 네트워크의 물리적인 구조를 정의하는 것으로 볼 수 있습니다.

캐시 토폴로지는 주로 컴퓨터 시스템 내부의 캐시 메모리 간의 연결과 배치를 설명하는 데 사용됩니다. 캐시는 데이터나 명령어 등을 임시로 저장하여 프로세서가 더 빠르게 접근할 수 있도록 돕는 고속 메모리입니다. 이러한 캐시들은 CPU와 주기억장치(RAM) 사이에 위치하며, 계층적인 구조를 가집니다.

캐시 토폴로지에서 사용되는 일반적인 구성 요소들은 다음과 같습니다:

레벨(Level): 캐시 메모리 계층은 다양한 레벨(레벨 1, 레벨 2, 등)으로 나뉘어집니다. 일반적으로 낮은 레벨일수록 CPU에 가깝고 속도가 빠릅니다.
코어(Core): 멀티코어 프로세서에서 각각의 코어마다 개별적인 캐시가 할당됩니다.
연결 방식: 캐시들 사이의 연결 방식에 따라 다양한 토폴로지가 있습니다. 대표적인 예로 버스(Bus), 크로스바(Crossbar), 리간드(Ring) 등이 있으며, 이러한 연결 방식은 데이터 전송 속도와 지연 시간에 영향을 줍니다.
배치(Banking): 여러 개의 동일한 크기와 용량을 가진 부분 집합으로 나뉜 캐시 메모리 모듈이 있는 경우, 이러한 부분 집합들을 어떻게 배치하느냐도 중요합니다.
이러한 요소들을 고려하여 최상의 성능과 효율성을 제공하기 위해 선택된 특정 형태의 네트워크 구조를 "캐시 토폴로지"라고 합니다. 각각의 토폴로지 형태는 장단점과 목적에 따라 선택되며, 시스템 아키텍처 및 응용 프로그램 요구 사항에 맞추어 설계됩니다.

### 캐시망은 어떻게 어떤 부모 캐시와 대화할 것인지, 아니면 요청이캐시를 우회해서 원 서버로 가도록 할 것인지에 대해 동적으로 결정을 하는가?

1. 캐시 상태: 해당 캐시가 현재 요청된 데이터를 가지고 있는지 여부에 따라서도 이 결정이 달라질 수 있습니다. 만약 해당 데이터가 캐시에 이미 저장되어 있다면, 그 캐시에서 바로 데이터를 가져올 것입니다. 그러나 만약 해당 데이터가 없다면, 부모 캐시 또는 원 서버로의 요청이 필요할 것입니다.
2. 트래픽 및 성능: 네트워크의 현재 트래픽 상태나 부모 캐시의 응답 시간 등도 고려될 수 있습니다. 예를 들어, 부모 캐시까지의 네트워크 경로가 혼잡하거나 응답 시간이 늦다면, 원 서버로 직접 요청을 보내는 것이 더 빠를 수 있습니다.
3. 정책 및 설정: 사용자 정책 또는 설정도 고려됩니다. 예를 들어 어떤 경우에는 특정 종류의 요청을 항상 원 서버로 직접 보내야 하는 등의 정책이 설정되어 있을 수 있습니다.
4. 계층 구조: 일부 네크워크에서는 여러 계층(레벨)의 중간(인터미디엣) 캐싱을 사용하여 성능과 효율성을 개선합니다.

### 캐시 로깅에 사용되는 스쿼드 로그 포맷, 넷스케이프 확장 공용 로그 포맷

- 스쿼드(Squid) 로그 포맷: 스쿼드는 대표적인 오픈 소스 프록시 서버로, 그 자체의 특정한 로깅 형식을 가지고 있습니다. 이 형식은 다양한 정보를 제공하는데, 일반적으로 다음과 같은 필드를 포함합니다:
  - 타임스탬프: 요청이 처리된 시간
  - 처리 시간: 요청을 처리하는 데 걸린 시간
  - 클라이언트 주소: 요청한 클라이언트의 IP 주소
  - 결과 코드/HTTP 상태 코드: 요청 결과와 HTTP 상태 코드
  - 바이트 수: 전송된 바이트 수
  - 메서드: HTTP 메서드(GET, POST 등)
  - URL: 요청된 URL
  - 사용자 이름: 인증된 사용자 이름(사용 가능한 경우)
  - 계층 정보/HIT/MISS 정보 등
- 넷스케이프 확장 공용 로그 포맷(ECLF): 이 형식은 원래의 공용 로그 포맷(Common Log Format, CLF)에 몇 가지 추가 필드가 있는 것으로, 웹 서버가 클라이언트와 통신할 때 생성되는 데이터를 기록합니다. 일반적으로 다음과 같은 필드를 포함합니다:

  - 클라이언트 호스트명/IP 주소
  - 인증된 사용자 이름(사용 가능한 경우)
  - [date/time]: 요청 받은 날짜와 시간 "요청": 문자열 안에 HTTP 메서드(GET, POST 등), URL 및 HTTP 버전 정보가 들어있습니다.
    <br /> 상태 코드(HTTP status code): 응답에 대한 HTTP 상태 코드 전송된 바이트 수

- #### 차이점
  - 스쿼드 로그는 프록시 서버에서 발생하는 트래픽을 추적하고 기록하기 위해 설계되었습니다. 이는 클라이언트와 원격 서버 사이의 요청/응답을 중계하며 이를 캐싱하는 등의 역할을 하는 프록시 서버의 동작에 초점을 맞춥니다. 반면에 ECLF는 웹 서버 자체에서 발생한 요청과 응답에 대한 상세 정보를 기록하기 위해 설계되었습니다.

### max-age와 expires 중 어느 것이 우선적으로 고려되는가?

HTTP/1.1 명세에 따르면, Cache-Control: max-age와 Expires 헤더가 모두 포함되어 있는 경우에는 max-age 지시자가 우선적으로 고려됩니다.

이는 HTTP/1.0에서 사용되었던 'Expires'보다 더 정확한 메커니즘이기 때문입니다. 'Expires' 헤더는 클라이언트와 서버 간의 시간 차이나 동기화 문제로 인해 문제를 일으킬 수 있습니다. 반면에 'max-age'는 상대적인 시간을 나타내므로 이러한 문제를 피할 수 있습니다.

따라서 현대의 웹 애플리케이션에서는 대부분 'max-age' 지시자를 주로 사용하며, 하위 호환성을 위해 'Expires' 헤더도 함께 사용하는 경우가 많습니다. 그러나 이 둘 중 어느 것을 신뢰해야 하는지 혼란스러울 필요 없이, 웹 브라우저나 캐싱 프록시 등은 이미 이 규칙에 따라 동작하도록 설계되어 있습니다.

### Clock Skew

"Clock skew"는 시스템 내의 여러 클럭 사이에 존재하는 시간 차이를 의미합니다. 이는 컴퓨터, 서버, 네트워크 장치 등 다양한 디지털 시스템에서 발생할 수 있습니다.

컴퓨터 네트워크에서 클럭 스큐는 클라이언트와 서버 사이의 시간 차이로 인해 문제를 일으킬 수 있습니다. 예를 들어, HTTP 프로토콜에서 Expires 헤더는 절대적인 만료 날짜/시각을 설정하는데 사용되며, 이때 서버와 클라이언트 사이에 큰 시간 차가 있다면 문제가 발생할 수 있습니다.

클럭 스큐를 관리하고 최소화하기 위한 여러 가지 방법들이 있습니다:

- 시간 동기화 프로토콜: NTP(Network Time Protocol)과 같은 프로토콜을 사용하여 네트워크 내의 모든 장치들의 시계를 동기화 할 수 있습니다.
- 상대적인 시간 사용: HTTP/1.1 Cache-Control: max-age 지시자와 같은 메커니즘은 상대적인 시간을 사용하여 클럭 스큐 문제를 회피합니다. 이 지시자는 리소스가 신선하다고 판단될 수 있는 최대 기간을 초 단위로 나타내며, 이 값은 리소스를 받아올 때부터 측정됩니다.
- 클럭 스큐 보정: 일부 고급 애플리케이션 또는 데이터베이스 관리 시스템(DBMS)은 내부적으로 클럭 스큐를 감지하고 보정하는 메커니즘이 포함되어 있을 수 있습니다.

## 궁금한 점

- 193p 적중과 부적중의 구별에서 적중이 304응답을 준다고 했는데 200OK이기 때문에 알 수 없다? 무엇이 맞는가?
