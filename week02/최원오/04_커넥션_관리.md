## 공부 내용

- TCP 세그먼트 헤더는 데이터의 순서와 무결성을 검사하기 위해 사용되는 숫자 값을 포함
- TCP는 포트 번호를 통해 여러 개의 커넥션을 유지
- 발신지 IP & 포트, 수신지 IP & 포트로 유일한 커넥션을 생성

### TCP 커넥션 관리

#### 지연 원인

- TCP커넥션 핸드셰이크 지연
- HTTP 트랜잭션이 아주 큰 데이터를 주고 받지 않는 경우에는 핸드셰이크 연결 과정이 눈에 띄는 지연을 발생시킨다.
  ACK 패킷은 HTTP 요청 메시지 전체를 전달할 수 있을 만큼 큰 경우가 많고, HTTP 응답 메시지는 하나의 IP 패킷에도 담길 수 있다.
  (즉, 배보다 배꼽이 큰 경우가 많다. 연결 작업의 비용이 더 큰 경우가 많다.)

#### TCP 커넥션 재활용

- 확인응답 지연

  - 세그먼트의 수신자는 세그먼트를 온전히 전송 받았다는 확인 응답 패킷을 송신자에게 반환하는데 확인 응답은 크기가 작기 때문에 TCP는 같은 방향으로 송출되는 데이터 패킷에 확인응답을 편승(piggyback) 시킨다.
    즉, 확인 응답과 송출 데이터 패킷을 하나로 묶어 효율적으로 사용
    확인 응답을 특정 시간 동안 버퍼에 저장해 두고 송출 데이터를 찾아서 묶어 전송

- TCP Slow Start

  - TCP의 데이터 전송 속도는 커넥션이 만들어진 지 얼마나 지났는지에 따라 달라질 수 있다. 처음에는 최대 속도를 제한하다가 데이터가 성공적으로 전송됨에 따라 속도 제한을 높혀 나간다. (인터넷의 급작스러운 부하와 혼잡을 방지하기 위함)
  - 한 번에 전송할 수 있는 패킷의 수를 제한

- Nagle 알고리즘과 TCP_NODELAY

  - 다른 패킷이 전송 중이면 데이터는 버퍼에 저장되어 세그먼트가 최대 크기가 되면 전송한다.
  - TCP_NODELAY 파라미터 값으로 네이글 알고리즘 비활성화가 가능하다.
  - 문제
    - 크기가 작은 HTTP 메시지는 패킷을 채우지 못하기 때문에, 앞으로 생길지 아닐 지 모르는 추가적인 데이터를 기다리며 지연
    - 확인응답 지연과 함께 쓸 경우 네이글 알고리즘은 확인 응답이 도착할 때까지 데이터 전송을 멈추기 때문에 문제가 된다.

- TIME_WAIT의 누적과 포트 고갈
  - TCP 커넥션의 종단에서 커넥션을 끊으면 IP주소와 포트번호를 메모리의 작은 제어 영역에 저장해 둔다. (같은 Origin에 대한 새로운 TCP 커넥션을 생성하지 않기 위함)
  - 이전 커넥션과 관련된 패킷이 새로운 커넥션에 삽입되는 문제를 방지한다. 이전 패킷이 새로운 커넥션에 삽입되면 패킷은 중복되고 TCP 데이터는 충돌할 것

### HTTP 커넥션 관리

- 커넥션 토큰이 HTTP 헤더 필드 명을 가지고 있으면, 현재 커넥션만을 위한 정보이므로 다음 커넥션에 전달하면 안 된다.
- 커넥션 헤더에는 홉별 헤더 명을 기술하여 헤더를 보호한다.

#### 병렬 커넥션

- 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리, 커넥션 지연이 겹쳐짐으로써 총 지연시간 단축
- 클라이언트의 네트워크 대역폭이 좁을 경우 성능 상의 장점은 없다.
- 병렬 커넥션이 항상 더 빠르게 로드하는 것은 아니지만 화면의 여러 부분이 동시에 내려받아 지기 때문에 시각적으로 빠르다고 느낄 수 있다.

#### 지속 커넥션

- 사이트 지역성 - 일반적으로 같은 사이트에 여러 개의 커넥션을 맺음
- 처리가 완료된 후에도 연결된 상태로 있는 TCP 커넥션

## 알게된 점

### 지속 커넥션

- HTTP/1.1 에서는 keep-alive 커넥션 대신 개선된 지속 커넥션을 지원한다.
- HTTP/1.0의 keep-alive 커넥션과는 달리 기본으로 활성화 되어 있다. 즉, 별도 설정을 하지 않는 한 모든 커넥션을 지속 커넥션으로 취급한다.
- HTTP/1.1 애플리케이션은 트랜잭션이 끝난 다음 커넥션을 끊으려면 Connection: close 헤더를 명시해야 한다.

### 파이프라인 커넥션

- HTTP 메시지는 순번이 매겨져 있지 않기 때문에 응답은 요청 순서와 같게 와야 한다.
- POST 요청 같이 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해 보내면 안 된다. 에러 발생 시 어떤 것들이 서버에서 처리되었는지 클라이언트에서 알 방법이 없다.
  비멱등 요청을 재차 보내면 문제가 생길 수 있기 떄문에 위험한 메서드로 요청해선 안된다.

### 멱등 메서드

- GET
- HEAD
- PUT
- DELETE
- TRACE
- OPTIONS

### 비멱등 메서드

- POST

## 궁금한 점
